---
date: "2018-01-01"
last-mod: "2018-01-01"
title: "CQRS"
# categories: [ "Study", ]
# tags: [ "Study", ]
---

## CQRS
[CQRSとイベントソーシングの使用法、または「CRUDに何か問題でも？」](https://postd.cc/using-cqrs-with-event-sourcing/)を呼んだ結果をまとめ

## CRUD Architecutre
  - 昔に比べて行い処理やケースが複雑化(パーミッションなど
  - そもそも、write/readで検討要件が大きく異なる

  書き込み|読み込み
  ---|---
  データの整合性の維持|データの検索と抽出の効率化
  アトミックな更新／トランザクション|導出値（合計など）の算出
  バージョン管理（楽観的並行性制御／楽観的ロック）|複数のビューの提供
  書き込み権限の管理|行レベル、カラムレベルの権限管理
  


## CQRS（Command Query Responsibility Segregation：コマンドクエリ責務分離）

- 「Command」と「Query」で分離
  > CRUDと違ってCQRSは、データの読み込みと書き込みは違うものだという前提にもとづく考えかたです。

  > CQRSでは、データベースの操作をコマンド（データを書き換える操作）とクエリ（データを読み込む操作）の二つに分類します。

  > コマンドは一般に、操作の成否以上の情報を呼び出し側に返しません。また、クエリは冪等であることが保証されます。

  > 間にコマンドが挟まらないという前提で、同じクエリを何度実行しても結果は同じになるということです。

  > RESTでいうと、コマンドはPUTやPOSTに対応し、クエリはGETに対応するものです。

- モデルも分離
  > データを問い合わせる際に使うUserモデルとコマンドを実行するときに使うモデルとが違っていてもかまわないということです。

  > ユーザー情報を更新するというのではなく、「メールアドレスを変更する」「請求先情報を変更する」なとどいうコマンドを考えることができるのです。
  
  > 呼び出し元が変更しようとしているエンティティのフィールドが本当に変更してよいかどうかをチェックするのではなく、呼び出し元に特定のコマンドを実行する権限があるかどうかだけをチェックすればいいのです。
  
## イベントソーシング

具体的な実現アーキテクチャとして
- 相性がイベントソーシングと良い
> 会計処理では、入出金取引（売上や購入など）を元帳にだけ追記していくのががよいとされています。

> ...現在の口座残高は、必要に応じて過去のすべての取引から算出します。

## Storage Middleware(EventStore)

### 概要

> EventStoreは追記限定の不変なストリームとしてイベントを扱います

### メリット

> あらゆる更新に対応できるような単一のクエリモデルを維持する必要はありません。
> 「ユーザーの詳細情報の表示」「一日あたりのアクティブユーザー数のレポート出力」など、用途にあわせて最適化したクエリモデルをいくつでも作れるのです。

- [実際の使い方のQiita記事(EventStoreをMicroservicesとして実装するときのプロトコルの案)](https://qiita.com/suin/items/033f0fc9fd46bcca920f)

### メリット(Pickup)

- write queryはeventとして必ず残っているので
  1. 実証可能な監査証跡を残せる
  2. 履歴データに基づいて過去に存在したクエリモデルを作れる（...メリットがよくわからない）
  3. 副作用を気にせずに済む(...説明がよくわからない)
  4. トラブルシューティングやデバッグの助けになる
    イベントをコピーしてリプレイすれば
    - 問題の再現性が簡単になる
    - テスト自動化が簡単になる

## 所感

- CQRSはテクニックだと思っていただ、アーキテクチャレベルで異なる実現方法だった
- 現時点では文献も少なく、[DDD conference 2018でも研究実験段階](https://www.infoq.com/jp/news/2018/03/evolving-cqrs-event-sourcing)のよう
